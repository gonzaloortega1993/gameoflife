"""
Conway's Game of Life
---------------------

https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life

The "board of game" is a matrix formed by squares ("cells") that extends
by the infinit in every direction. Every cell has 8 neighbor cells, 
that are the cells surround it, diagonals included. The cells has two states: 
they are "alive" or "dead". The matrix state evolves evoluciona throught unitys of time
(it could be said by turns). The state of every cell is used for calculate
their state in the next turn. All the cells are refreshed at the same time.

The transitions depends of the number of neighbor alive cells:

*   One dead cell with exactky 3 neighbor alive cells "borns"
    (In the next turn will be alive).
  
*   One alive cell with 2 or 3 neighbor alive cells continue alive,
    in other case dies or stay dead.
"""

def main():
    """
    Main function of the program. Creates the initial state of the Game of LIfe
    and shows the simulation step by step while the user press Enter.
    """
    life = life_create([
        '..........',
        '.#.....#.#',
        '..#....#..',
        '...#.####.',
        '...#...#..',
        '...###....',
        '...#...#..',
        '..#......#',
    ])
    while True:
        for line in life_show(life):
            print(line)
        print()
        input("Press Enter to continue, CTRL+C to finish")
        print()
        life = following_life(life)

#-----------------------------------------------------------------------------

def life_create(map_):
    """
    Creates the initial state of Game of life based on a disposition
    represented with '.' and '#' characters.

    `map_` should be a list of strings, every sting represents a file of the 
    board and every character can be '.' (empty) o '#' (cell).
    Every file must have the same amount of characters.

    Returns the state of the game, is a list of lists where each sublist
    represents a file, and every element of the file is False (empty)
    o True (cell).
    """
    life=[]
    for string in map_:
        row=[]
        for value in string:
            if value ==".":
                row.append(False)
            elif value == "#":
                row.append(True)
        life.append(row)
    return life

def test_life_create():
    """Checks that life_create() works properly."""
    # For each test uses the instruction `assert <condition>`, that
    # evaluates the <condition> be true and returns an error in the opossite case
    assert life_create([]) == []
    assert life_create(['.']) == [[False]]
    assert life_create(['#']) == [[True]]
    assert life_create(['#.', '.#']) == [[True, False], [False, True]]

#-----------------------------------------------------------------------------

def life_show(life):
    """
    Creates a representation of the game's state to show in the screen.

    Receives the state of the game (Trues & Falses) created with life_create() and
    returns a list of strings (every character must be '.' (empty) or '#' (cell))
    with the representation of the board to show in the screen.
    Every string represents a row.
    """
    show = []
    for list_ in life:
        row = ""
        for value in list_:
            if value == False:
                row += "."
            elif value == True:
                row += "#"
        show.append(row)
    return show

def test_life_show():
    """Checks that life_show() works correctly."""
    assert life_show([]) == []
    assert life_show([[False]]) == ['.']
    assert life_show([[True]]) == ['#']
    assert life_show([[True, False], [False, True]]) == ['#.', '.#']

#-----------------------------------------------------------------------------

def adjacents_amount(life, r, c):
    '''Recives a list of strings (life_show) representing the state of the board and one position (r and c).
    Calculates the quantity of alive cells around the position of the cell. As the board is infinite, when
    the lenght of life is less than 9 cells the board is mirrored.
    To calculate the amount of alive cells around determinated cell we access: 
    * To the state of life[f-1][c-1], life[f-1][c], life[f-1][c_+_1], 
    * To the state of  life[f][c-1], life[f][c_+_1], 
    * To the state of  life[f+1][c-1], life[f+1][c], life[f+1][c_+_1], 

    For example if the board is generated by life_create(['.']) all the cells will be == None, they replicates.
    '''
    
    
    amount = 0

    row_up = life[r-1]
    row_down = life[(r+1) % len(life)]
    column_plus_one=(c+1) % len(life[0])

    adjacents = [row_up[c-1], row_up[c], row_up[column_plus_one], 
                    life[r][c-1], life[r][column_plus_one],
                row_down[c-1], row_down[c], row_down[column_plus_one]]

    for cell in adjacents:
        if cell == True:
            amount += 1
    return amount

def test_adjacents_amount():
    """Checks that adjacents_amount() works properly."""
    assert adjacents_amount(life_create(['.']), 0, 0) == 0
    assert adjacents_amount(life_create(['#']), 0, 0) == 8
    assert adjacents_amount(life_create(['..', '..']), 0, 0) == 0
    assert adjacents_amount(life_create(['..', '..']), 0, 1) == 0
    assert adjacents_amount(life_create(['##', '..']), 0, 0) == 2
    assert adjacents_amount(life_create(['##', '..']), 0, 1) == 2
    assert adjacents_amount(life_create(['#.', '.#']), 0, 0) == 4
    assert adjacents_amount(life_create(['##', '##']), 0, 0) == 8
    assert adjacents_amount(life_create(['.#.', '#.#', '.#.']), 1, 1) == 4
    assert adjacents_amount(life_create(['.#.', '..#', '.#.']), 1, 1) == 3
    assert adjacents_amount(life_create(['...', '.#.', '...']), 1, 1) == 0

#-----------------------------------------------------------------------------

def following_cell(life, r, c):
    """
    Calculates the following state of the cell located in the row `r` and the
    column `c`.

    Returns True if the cell (r, c) will be alive in the next iteration
    or False if the cell will be empty.

    * One dead cell with exactly 3 neighbor alive cells "borns" (in the following
    turn will be alive).
    * One alive cell with 3 or 2 alive neighbor cells continues alive, in other case
    deads or continue dead.
    """
    cell = life[r][c]
    n = adjacents_amount(life, r, c)
    if cell == False:
        if n == 3:
            return True
        return False
    if n > 1 and n < 4:
        return True
    return False

def test_following_cell():
    """Checks that following_cell() works correctly."""
    assert following_cell(life_create(['.']), 0, 0) == False
    assert following_cell(life_create(['..', '..']), 0, 0) == False
    assert following_cell(life_create(['..', '..']), 0, 1) == False
    assert following_cell(life_create(['##', '..']), 0, 0) == True
    assert following_cell(life_create(['##', '..']), 0, 1) == True
    assert following_cell(life_create(['#.', '.#']), 0, 0) == False
    assert following_cell(life_create(['##', '##']), 0, 0) == False
    assert following_cell(life_create(['.#.', '#.#', '.#.']), 1, 1) == False
    assert following_cell(life_create(['.#.', '..#', '.#.']), 1, 1) == True
    assert following_cell(life_create(['...', '.#.', '...']), 1, 1) == False

#-----------------------------------------------------------------------------

def following_life(life):
    """
    Calculates the following game state

    Receives the actual state of the game (list of lists of False/True) and
    returns a new state that represents the following iteration.

    Import: The "board" is considered "infinit": the cells of the left edge
    are connected at the left with the right edge cells and, vice versa.
    The cells of the superior edhe are connected at the up with the inferior 
    edge and vice versa.
    """
    following = []
    for r in range(len(life)):
        row = []
        for c in range(len(life[0])):
            row.append(following_cell(life, r, c))
        following.append(row)
    return following

#-----------------------------------------------------------------------------

def tests():
    """Executes all the tests"""
    test_life_create()
    test_life_show()
    test_adjacents_amount()
    test_following_cell()
main()
tests()
